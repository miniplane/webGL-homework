<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=utf-8">

<script type="text/javascript" src="http://benvanik.github.io/WebGL-Inspector/core/embed.js" async></script>
<script type="text/javascript" src="jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="init_buffers.js"></script>
<script type="text/javascript" src="load_model.js"></script> 

<script type="text/javascript" src="draw_scene.js"></script>
<script type="text/javascript" src="controls.js"></script>
<script type="text/javascript" src="transformations.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	varying vec4 vColor;
	varying vec3 vLightWeighting;

	void main(void) {
		gl_FragColor = vec4(vColor.rgb * vLightWeighting, vColor.a);
    }

</script>

<script id="shader-vs" type="x-shader/x-vertex">

	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec4 aVertexColor;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	uniform vec3 uAmbientColor;
	uniform vec3 uDirectionalColor;

	uniform vec3 uLightingDirection;

	uniform bool uUseLighting;

	varying vec4 vColor;
	varying vec3 vLightWeighting;

	void main(void) {
		mat4 uNMatrix;
		uNMatrix = uMVMatrix;

		vec4 transformedPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * transformedPosition;
		vColor = aVertexColor;

		if (!uUseLighting)
			vLightWeighting = vec3(1.0, 1.0, 1.0);
		else {
			vec3 transformedNormal = normalize(mat3(uNMatrix) * aVertexNormal);
			vec3 towardsCamera = normalize(vec3(transformedPosition));
			float diffuseReflection = max(dot(transformedNormal, uLightingDirection), 0.0);

			float specular_components = max(dot(towardsCamera, reflect(transformedNormal, uLightingDirection)), 0.0);
			float specularReflection = pow(specular_components, 30.0);
			vLightWeighting = uAmbientColor +
			                  uDirectionalColor * diffuseReflection +
			                  uDirectionalColor * specularReflection;
		}

	}
</script>


<script type="text/javascript">

	var gl;
	function initGL(canvas) {
		try {
			gl = canvas.getContext("experimental-webgl");
			gl.viewportWidth = canvas.width;
			gl.viewportHeight = canvas.height;
		} catch (e) {
		}
		if (!gl) {
			console.error("Could not initialise WebGL");
			document.getElementById("messages").innerText = "Could not initialise WebGL";
		}
	}


	function getShader(gl, id) {
		var shaderScript = document.getElementById(id);
		if (!shaderScript) {
			return null;
		}

		var str = "";
		var k = shaderScript.firstChild;
		while (k) {
			if (k.nodeType == 3) {
				str += k.textContent;
			}
			k = k.nextSibling;
		}

		var shader;
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, str);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}

		return shader;
	}


		function change_lighting_mode(lighting_mode) { // lighting_mode can switch between modes like phong and gouraud shading
		
		if (lighting_mode == 1)
			shaderProgram = shaderProgramGouraud;

		gl.uniform1i(shaderProgram.useLightingUniform, lighting_mode);

		// ambient
		gl.uniform3f(shaderProgram.ambientColorUniform, 0.2, 0.2, 0.2); 

		// directional
		var lighting_direction = [0, 0, 1];
		var adjustedLD = vec3.create();
		vec3.normalize(lighting_direction, adjustedLD);
		// vec3.scale(adjustedLD, -1);

		gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
		gl.uniform3f(shaderProgram.directionalColorUniform, 0.5, 0.5, 0.5); // lighting color
	}


	var shaderProgram;
	var shaderProgramGouraud;


	function initShaders() {

		var fragmentShaderGouraud = getShader(gl, "shader-fs");
		var vertexShaderGouraud = getShader(gl, "shader-vs");


		shaderProgramGouraud = gl.createProgram();
		gl.attachShader(shaderProgramGouraud, vertexShaderGouraud);
		gl.attachShader(shaderProgramGouraud, fragmentShaderGouraud);
		gl.linkProgram(shaderProgramGouraud);

		if (!gl.getProgramParameter(shaderProgramGouraud, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgramGouraud);

		shaderProgramGouraud.vertexPositionAttribute = gl.getAttribLocation(shaderProgramGouraud, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgramGouraud.vertexPositionAttribute);

		shaderProgramGouraud.vertexColorAttribute = gl.getAttribLocation(shaderProgramGouraud, "aVertexColor");
		gl.enableVertexAttribArray(shaderProgramGouraud.vertexColorAttribute);

		shaderProgramGouraud.vertexNormalAttribute = gl.getAttribLocation(shaderProgramGouraud, "aVertexNormal");
		gl.enableVertexAttribArray(shaderProgramGouraud.vertexNormalAttribute);

		shaderProgramGouraud.mvMatrixUniform = gl.getUniformLocation(shaderProgramGouraud, "uMVMatrix");
		shaderProgramGouraud.pMatrixUniform = gl.getUniformLocation(shaderProgramGouraud, "uPMatrix");
		shaderProgramGouraud.ambientColorUniform = gl.getUniformLocation(shaderProgramGouraud, "uAmbientColor");
		shaderProgramGouraud.directionalColorUniform = gl.getUniformLocation(shaderProgramGouraud, "uDirectionalColor");
		shaderProgramGouraud.lightingDirectionUniform = gl.getUniformLocation(shaderProgramGouraud, "uLightingDirection");
		shaderProgramGouraud.useLightingUniform = gl.getUniformLocation(shaderProgramGouraud, "uUseLighting");
	}




	var mvMatrix = mat4.create();
	var pMatrix = mat4.create();

	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

	function webGLStart() {
		var canvas = document.getElementById("canvas");
		initGL(canvas);
		initShaders();
		init_buffers();
		loadScene();
		build_scene();
		keyboard_input();

		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.enable(gl.DEPTH_TEST);
		// gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // transparency
		gl.enable(gl.BLEND);
		gl.enable(gl.CULL_FACE);

		//document.addEventListener("keydown", func);

		tick();
	}

	function tick() {
    	requestAnimationFrame(tick); // webgl-utils.js
    	draw_scene();
    	animate();
    }


	function animate() {
		var timeNow = new Date().getTime();
		elapsed = timeNow - lastTime;
		lastTime = timeNow;
	}

	var lastTime = new Date().getTime();
	var elapsed = 0;

    var selected_object_id = 0;


</script>


</head>


<body onload="webGLStart();">

	<canvas id="canvas" style="border: none;" width="1000" height="1000"></canvas>
	<div id="messages"></div>

</body>

</html>
